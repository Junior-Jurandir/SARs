# -*- coding: utf-8 -*-
"""teste_random_forest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fZoFdGM5vuQ0D0eA6DFvjFtWrG-TLVeu

# Notebook de teste da Random Forest para Daytrade

## 1ï¸âƒ£ Imports e ConfiguraÃ§Ã£o Inicial
"""

# !pip install pandas
# !pip install scikit-learn
# !pip install matplotlib
# !pip install seaborn


import pandas as pd
import numpy as np


from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score


import matplotlib.pyplot as plt
import seaborn as sns


pd.set_option('display.max_columns', None)

"""## 2ï¸âƒ£ Carregamento dos Dados"""

df = pd.read_csv('C:\Users\Jurandir\OneDrive - CMC\Documentos\Scripts de investimento\SARs\data\logs antigos\sar_sinais.csv', parse_dates=['data'])


df.head()

"""## 3ï¸âƒ£ Limpeza e SeleÃ§Ã£o dos Dados

Posteriormente vamos treinar somente com sinais APROVADOS (o robÃ´ teria entrado neles).
"""

# df = df[df['status'] == 'APROVADO'].copy()

"""Criamos o label binÃ¡rio:"""

df['y'] = (df['resultado_teorico'] == 'WIN').astype(int)

"""## 4ï¸âƒ£ Engenharia de Features

Selecionamos apenas informaÃ§Ãµes que estariam disponÃ­veis no momento da decisÃ£o:
"""

X = df[[
'adx',
'ema_ok',
'adx_ok'
]]


y = df['y']

# X = df[[
#     'direcao_sar'
#     'tendencia_ema',
#     'ema_ok',
#     'adx',
#     'adx_ok'
# ]]


# y = df['y']

"""Converter booleanos:"""

X['ema_ok'] = X['ema_ok'].astype(str).map({'True': 1, 'False': 0})
X['adx_ok'] = X['adx_ok'].astype(str).map({'True': 1, 'False': 0})

"""## 5ï¸âƒ£ Split Treino / Teste"""

X_train, X_test, y_train, y_test = train_test_split(
X, y,
test_size=0.3,
random_state=42,
stratify=y
)

"""## 6ï¸âƒ£ Treinamento do Random Forest"""

model = RandomForestClassifier(
n_estimators=300,
max_depth=6,
min_samples_leaf=20,
random_state=42,
class_weight='balanced'
)


model.fit(X_train, y_train)

"""## 7ï¸âƒ£ AvaliaÃ§Ã£o do Modelo"""

y_pred = model.predict(X_test)
y_prob = model.predict_proba(X_test)[:, 1]

"""RelatÃ³rio"""

print(classification_report(y_test, y_pred))

"""Matriz de ConfusÃ£o"""

cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', xticklabels=['Loss', 'Win'], yticklabels=['Loss', 'Win'])
plt.xlabel('Predito')
plt.ylabel('Real')
plt.title('Matriz de ConfusÃ£o: Real vs. Predito (0=Loss, 1=Win)')
plt.show()

"""AUC ROC"""

roc_auc_score(y_test, y_prob)

"""## 8ï¸âƒ£ ImportÃ¢ncia das Features"""

importances = pd.Series(
model.feature_importances_,
index=X.columns
).sort_values(ascending=False)


importances.plot(kind='bar', title='ImportÃ¢ncia das Features')
plt.show()

"""ðŸ‘‰ Isso mostra o que realmente importa para o mercado, nÃ£o o que achamos.

## 9ï¸âƒ£ SimulaÃ§Ã£o de Filtro Inteligente

Aceitar apenas sinais com probabilidade â‰¥ 60%:
"""

df['prob_win'] = model.predict_proba(X)[:, 1]


filtro_ia = df[df['prob_win'] >= 0.6]


print('Trades antes:', len(df))
print('Trades apÃ³s IA:', len(filtro_ia))
print('Win rate original:', df['y'].mean())
print('Win rate IA:', filtro_ia['y'].mean())

"""## ðŸ”Ÿ Exportar o modelo"""

# Salva os arquivos
# joblib.dump(model, "rf_model.pkl")
# joblib.dump(scaler, "scaler.pkl")